name: Automated Proxy Management (Integrated Python & Mihomo)

on:
  workflow_dispatch: # 允许手动触发
  schedule:
    - cron: '0 */6 * * *' # 每6小时运行一次

jobs:
  process_proxies:
    runs-on: ubuntu-latest
    permissions:
      contents: write # 授予写入权限，以便推送结果文件

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set up Python (for YAML processing)
        uses: actions/setup-python@v5
        with:
          python-version: '3.9' # 使用一个稳定的Python版本

      - name: Install Python dependencies
        run: |
          pip install PyYAML requests

      - name: Set up Node.js (for final YAML processing)
        uses: actions/setup-node@v4
        with:
          node-version: '16'

      - name: Install Node.js YAML dependencies
        run: npm install js-yaml yq # 安装 yq 工具来更方便地处理 YAML

      - name: Create data directory
        run: mkdir -p data

      - name: Download Mihomo (Clash Meta) Core for Speed Testing
        run: |
          MIHOMO_VERSION="v1.18.2" # 请务必检查 mihomo Release 页面获取最新版本号
          DOWNLOAD_URL="https://github.com/MetaCubeX/mihomo/releases/download/${MIHOMO_VERSION}/mihomo-linux-amd64-${MIHOMO_VERSION}.gz"
          echo "Attempting to download mihomo from: ${DOWNLOAD_URL}"
          
          curl -L --fail --retry 5 --retry-delay 5 -o mihomo.gz "${DOWNLOAD_URL}"
          
          gzip -t mihomo.gz || { echo "Downloaded mihomo file is not a valid gzip. Aborting."; exit 1; }

          gzip -d mihomo.gz
          chmod +x mihomo # 授予执行权限

      - name: Download and Process Clash Config with Python
        run: |
          python -c "
import requests
import yaml
import sys
import re

config_url = 'https://raw.githubusercontent.com/qjlxg/vt/refs/heads/main/clash_config.yaml'
output_file = 'converted_clash.yaml'

try:
    response = requests.get(config_url)
    response.raise_for_status() # Raises an HTTPError for bad responses (4xx or 5xx)
    
    # 尝试加载整个YAML文件
    full_config = yaml.safe_load(response.text)
    
    # 确保 'proxies' 键存在并且是列表
    proxies = full_config.get('proxies', [])
    if not isinstance(proxies, list):
        print('Error: \"proxies\" key is not a list in the source config.', file=sys.stderr)
        proxies = []

    cleaned_proxies = []
    for proxy in proxies:
        if isinstance(proxy, dict) and 'name' in proxy:
            original_name = proxy['name']
            # 移除所有非 ASCII 字符，包括表情符号
            cleaned_name = re.sub(r'[^\x00-\x7F]+', '', original_name)
            # 移除常见的分隔符和多余空格，并确保名称不为空
            cleaned_name = re.sub(r'[\s|/-]+', ' ', cleaned_name).strip()
            if not cleaned_name: # 如果清理后名称为空，则尝试使用默认名或跳过
                cleaned_name = f'Unnamed_Proxy_{len(cleaned_proxies) + 1}' # 从1开始计数
            proxy['name'] = cleaned_name
        cleaned_proxies.append(proxy)
    
    # 创建只包含代理的YAML结构
    final_output = {'proxies': cleaned_proxies}
    
    with open(output_file, 'w', encoding='utf-8') as f:
        yaml.dump(final_output, f, allow_unicode=True, default_flow_style=False, indent=2)
    
    print(f'Successfully processed {len(cleaned_proxies)} proxies from {config_url} to {output_file}')

except requests.exceptions.RequestException as e:
    print(f'Error fetching config from URL: {e}', file=sys.stderr)
    sys.exit(1)
except yaml.YAMLError as e:
    print(f'Error parsing YAML: {e}', file=sys.stderr)
    sys.exit(1)
except Exception as e:
    print(f'An unexpected error occurred: {e}', file=sys.stderr)
    sys.exit(1)
" > python_process_log.txt 2>&1 # 将Python的输出重定向到文件，包括错误

          # 检查 Python 脚本是否成功生成了文件
          if [ ! -s "converted_clash.yaml" ]; then
            echo "Error: converted_clash.yaml was not generated or is empty by Python script. Check python_process_log.txt for details."
            cat python_process_log.txt # 输出Python日志方便调试
            exit 1
          fi

      - name: Perform Speed Test with Mihomo Core
        run: |
          if [ ! -s "converted_clash.yaml" ]; then
            echo "Error: converted_clash.yaml is empty or does not exist. Skipping speed test."
            exit 1
          fi

          echo "proxies: $(yq '.proxies // []' converted_clash.yaml)" > test_config.yaml
          echo "external-controller: 127.0.0.1:9090" >> test_config.yaml
          echo "log-level: info" >> test_config.yaml
          
          ./mihomo -f test_config.yaml &
          MIHOMO_PID=$!
          sleep 5 # 给 Mihomo 启动时间

          NODE_NAMES=$(yq '.proxies[].name // []' converted_clash.yaml | tr '\n' ' ')
          if [ -z "$NODE_NAMES" ]; then
            echo "No nodes found in converted_clash.yaml. Skipping speed test."
            kill $MIHOMO_PID # 确保 mihomo 关闭
            sleep 1
            exit 0 # 成功结束，因为没有节点可测
          fi

          echo "Testing nodes: $NODE_NAMES"

          RESULTS_FILE="test_results.txt"
          echo "" > $RESULTS_FILE

          for NODE_NAME in $NODE_NAMES; do
            echo "Testing $NODE_NAME..."
            LATENCY=$(curl -s -X GET "http://127.0.0.1:9090/proxies/$NODE_NAME/delay?url=https://www.google.com/generate_204&timeout=5000" | jq -r '.delay')
            if [ "$LATENCY" == "null" ] || [ "$LATENCY" == "" ]; then
              LATENCY="Timeout/Error"
            fi
            echo "$NODE_NAME: $LATENCY ms" >> $RESULTS_FILE
          done
          
          kill $MIHOMO_PID # 关闭 Mihomo
          sleep 1

      - name: Filter and Organize Proxies Based on Speed Test
        run: |
          node -e '
            const fs = require("fs");
            const yaml = require("js-yaml");

            try {
              if (!fs.existsSync("converted_clash.yaml") || fs.statSync("converted_clash.yaml").size === 0) {
                console.warn("converted_clash.yaml is empty or does not exist. No proxies to process.");
                process.exit(0);
              }

              const fullConfig = yaml.load(fs.readFileSync("converted_clash.yaml", "utf8"));
              const allProxies = fullConfig ? (fullConfig.proxies || []) : []; // 确保 proxies 是一个数组

              if (!allProxies || !Array.isArray(allProxies) || allProxies.length === 0) {
                console.warn("No proxies found in converted_clash.yaml after initial load. Generating empty config.");
                const emptyConfig = {
                    "port": 7890, "socks-port": 7891, "allow-lan": false, "mode": "rule",
                    "log-level": "info", "external-controller": "0.0.0.0:9090",
                    "proxies": [], "proxy-groups": [{"name": "Proxy", "type": "select", "proxies": []}, {"name": "Direct", "type": "direct"}],
                    "rules": ["MATCH,Proxy"]
                };
                fs.writeFileSync("data/clash.yaml", yaml.dump(emptyConfig, { indent: 2 }));
                process.exit(0);
              }

              const testResults = fs.readFileSync("test_results.txt", "utf8").split("\n").filter(line => line.trim() !== "");

              const proxyLatencyMap = new Map();
              testResults.forEach(line => {
                const parts = line.split(": ");
                if (parts.length === 2) {
                  const name = parts[0];
                  let latency = parseInt(parts[1]);
                  if (isNaN(latency) || latency === 0) {
                    latency = Infinity; // 将无法获取延迟的节点视为不可用
                  }
                  proxyLatencyMap.set(name, latency);
                }
              });

              // 过滤掉延迟为 Infinity 的节点（即无法测速或超时）
              const sortedAndFilteredProxies = allProxies
                .filter(p => p && p.name && proxyLatencyMap.has(p.name) && proxyLatencyMap.get(p.name) < Infinity)
                .sort((a, b) => proxyLatencyMap.get(a.name) - proxyLatencyMap.get(b.name));
              
              if (sortedAndFilteredProxies.length === 0) {
                console.warn("No healthy proxies found after speed test. Generating empty config.");
                const emptyConfig = {
                    "port": 7890, "socks-port": 7891, "allow-lan": false, "mode": "rule",
                    "log-level": "info", "external-controller": "0.0.0.0:9090",
                    "proxies": [], "proxy-groups": [{"name": "Proxy", "type": "select", "proxies": []}, {"name": "Direct", "type": "direct"}],
                    "rules": ["MATCH,Proxy"]
                };
                fs.writeFileSync("data/clash.yaml", yaml.dump(emptyConfig, { indent: 2 }));
                process.exit(0);
              }

              const finalConfig = {
                "port": 7890,
                "socks-port": 7891,
                "allow-lan": false,
                "mode": "rule",
                "log-level": "info",
                "external-controller": "0.0.0.0:9090",
                "proxies": sortedAndFilteredProxies,
                "proxy-groups": [
                    {
                        "name": "Proxy",
                        "type": "select",
                        "proxies": sortedAndFilteredProxies.map(p => p.name)
                    },
                    {
                        "name": "Direct", # 添加一个 Direct 组，确保有回退选项
                        "type": "direct"
                    }
                ],
                "rules": [
                    "MATCH,Proxy" # 默认所有流量走 Proxy 组
                ]
              };

              fs.writeFileSync("data/clash.yaml", yaml.dump(finalConfig, { indent: 2 }));
              console.log("Proxies collected, converted, tested, and saved successfully!");

            } catch (e) {
              console.error("Error processing proxies:", e);
              process.exit(1);
            }
          '
