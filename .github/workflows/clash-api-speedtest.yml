# 工作流名称
name: Clash API Speed Test and Sort

# 触发工作流的事件
on:
  workflow_dispatch: # 手动触发
  schedule:
    - cron: '0 */4 * * *' # 每4小时运行一次，可以根据需要调整

jobs:
  api-speed-test:
    runs-on: ubuntu-latest
    steps:
      - name: 检出仓库
        uses: actions/checkout@v4

      - name: 设置 Python 环境
        uses: actions/setup-python@v5
        with:
          python-version: '3.x'

      - name: 安装 Python 依赖
        run: |
          pip install PyYAML requests

      - name: 下载 Clash Core (Mihomo)
        id: download_clash_core
        run: |
          # 推荐使用 Mihomo 作为 Clash Core
          # 访问 https://github.com/MetaCubeX/mihomo/releases 确认最新版本
          MIHOMO_VERSION="1.19.11" # 您可以根据需要更新到最新版本
          ARCHIVE_NAME="mihomo-linux-amd64-v${MIHOMO_VERSION}.gz"
          MIHOMO_URL="https://github.com/MetaCubeX/mihomo/releases/download/v${MIHOMO_VERSION}/${ARCHIVE_NAME}"
          EXECUTABLE_SOURCE_NAME="mihomo-linux-amd64-v${MIHOMO_VERSION}" # 解压后的原始文件名称
          EXECUTABLE_NAME="mihomo" # 我们希望最终的可执行文件名称

          echo "尝试下载 Mihomo Core ${ARCHIVE_NAME}..."
          curl -S -L --retry 5 --retry-delay 5 --connect-timeout 10 --max-time 60 --output "$ARCHIVE_NAME" "$MIHOMO_URL"
          if [ $? -ne 0 ]; then
            echo "错误: curl 命令执行失败，无法下载 Mihomo Core 文件。"
            exit 1
          fi
          if [ ! -f "$ARCHIVE_NAME" ]; then
            echo "错误: Mihomo Core 文件不存在。下载可能失败。"
            exit 1
          fi
          if [ ! -s "$ARCHIVE_NAME" ]; then
            echo "错误: Mihomo Core 文件为空。下载可能失败。"
            exit 1
          fi
          echo "Mihomo Core 下载成功，大小: $(du -h "$ARCHIVE_NAME" | awk '{print $1}')"

          echo "解压 ${ARCHIVE_NAME}..."
          gzip -d "$ARCHIVE_NAME" # 解压 .gz 文件，会生成 EXECUTABLE_SOURCE_NAME

          # 重命名解压后的文件
          if [ -f "./${EXECUTABLE_SOURCE_NAME}" ]; then
            echo "将 '${EXECUTABLE_SOURCE_NAME}' 重命名为 '${EXECUTABLE_NAME}'..."
            mv "./${EXECUTABLE_SOURCE_NAME}" "./${EXECUTABLE_NAME}"
          else
            echo "错误: 解压后未找到原始可执行文件 '${EXECUTABLE_SOURCE_NAME}'。"
            exit 1
          fi

          FILE_TYPE_INFO=$(file "./${EXECUTABLE_NAME}")
          echo "${EXECUTABLE_NAME} 文件类型信息: ${FILE_TYPE_INFO}"
          if ! echo "$FILE_TYPE_INFO" | grep -q "ELF 64-bit LSB executable"; then
              echo "错误: ${EXECUTABLE_NAME} 文件不是预期的 Linux AMD64 可执行文件。请检查文件是否损坏或上传了错误版本。"
              exit 1
          fi
          chmod +x "./${EXECUTABLE_NAME}"
          echo "'${EXECUTABLE_NAME}' 权限已设置并验证为可执行文件。"

      - name: 下载完整的 Clash 配置
        id: download_config
        run: |
          CONFIG_URL="https://raw.githubusercontent.com/qjlxg/vt/refs/heads/main/clash_config.yaml"
          OUTPUT_FILE="clash_config.yaml"
          echo "尝试从 $CONFIG_URL 下载完整的 Clash 配置文件..."
          curl -S -L -v --retry 5 --retry-delay 5 --connect-timeout 10 --max-time 60 --output "$OUTPUT_FILE" "$CONFIG_URL"
          if [ $? -ne 0 ]; then
            echo "错误: curl 命令执行失败，无法下载文件。"
            exit 1
          fi
          if [ ! -f "$OUTPUT_FILE" ]; then
            echo "错误: $OUTPUT_FILE 文件不存在。"
            exit 1
          fi
          if [ ! -s "$OUTPUT_FILE" ]; then
            echo "错误: $OUTPUT_FILE 文件为空。"
            head -n 20 "$OUTPUT_FILE" || true
            exit 1
          fi
          echo "$OUTPUT_FILE 文件下载成功，大小: $(du -h "$OUTPUT_FILE" | awk '{print $1}')"

      - name: 过滤节点 (使用 Python 脚本)
        run: python filter_clash_nodes.py
      
      - name: 验证过滤后的文件
        id: check_filtered_file
        run: |
          if [ ! -s "filtered_nodes.yaml" ]; then
            echo "警告: 'filtered_nodes.yaml' 文件为空或无有效内容。可能没有节点符合过滤条件。"
            echo "FILTERED_NODES_EMPTY=true" >> $GITHUB_OUTPUT 
            head -n 20 filtered_nodes.yaml || true
            exit 0
          fi
          echo "filtered_nodes.yaml 文件大小: $(du -h filtered_nodes.yaml | awk '{print $1}')"
          echo "FILTERED_NODES_EMPTY=false" >> $GITHUB_OUTPUT

      - name: 准备 Clash 核心配置
        if: steps.check_filtered_file.outputs.FILTERED_NODES_EMPTY == 'false'
        run: |
          # 创建一个简化的 Clash 配置来启动 Mihomo，只包含 proxy-providers
          # 确保 external-controller 和 secret 开启
          echo "正在生成 Mihomo 启动配置..."
          # Mihomo 会自动加载当前目录下的 proxies.yaml 或 provider 文件
          # 我们这里使用 proxy-providers 来加载 filtered_nodes.yaml
          cat > mihomo_config.yaml <<EOF
          # 最小化配置，用于启动 Mihomo
          port: 7890
          socks-port: 7891
          allow-lan: false
          mode: rule
          log-level: info
          external-controller: 127.0.0.1:9090
          secret: your_secret_token_here # 设置一个秘钥，Python脚本将使用它，请替换为您的实际密钥

          proxy-providers:
            filtered-proxies:
              type: file
              path: filtered_nodes.yaml # 引用过滤后的节点文件
              interval: 3600 # 1小时更新一次，此处不重要，因为我们手动测速
              health-check:
                enable: false # 禁用健康检查，避免干扰
          
          proxies:
            - {name: "Proxy Group", type: select, proxies: [{{ range .filtered-proxies.proxies }}{{ .name | quote }}, {{ end }}]} # 使用 proxy-providers 提供的节点
          
          # 规则部分（可选，此处不重要，因为主要目的是测速）
          rules:
            - 'MATCH,Proxy Group'
          EOF
          
          echo "mihomo_config.yaml 生成完毕:"
          cat mihomo_config.yaml

      - name: 启动 Clash Core (Mihomo)
        id: start_clash_core
        if: success() && steps.check_filtered_file.outputs.FILTERED_NODES_EMPTY == 'false'
        run: |
          echo "启动 Mihomo Core..."
          # 以后台模式启动 Mihomo
          # -d 参数指定工作目录
          # -f 参数指定配置文件
          ./mihomo -d . -f mihomo_config.yaml &
          MIHOMO_PID=$!
          echo "Mihomo Core 已启动，PID: $MIHOMO_PID"
          # 等待 Mihomo 启动并监听端口
          sleep 5 # 给予 Mihomo 足够的时间启动

          # 检查端口是否在监听
          if ! netstat -tuln | grep -q "127.0.0.1:9090"; then
            echo "错误: Mihomo Core 未能在 9090 端口启动。请检查日志。"
            kill $MIHOMO_PID || true # 尝试杀死进程
            exit 1
          fi
          echo "Mihomo Core 已成功启动并监听 9090 端口。"
          echo "MIHOMO_PID=$MIHOMO_PID" >> $GITHUB_OUTPUT # 导出 PID 供后续步骤使用

      - name: 运行 Python 脚本进行 API 测速和排序
        id: run_api_speedtest
        if: success() && steps.check_filtered_file.outputs.FILTERED_NODES_EMPTY == 'false' && steps.start_clash_core.outcome == 'success'
        run: |
          echo "开始运行 Python 脚本进行 API 测速和排序..."
          # 将 SECRET_TOKEN 传递给 Python 脚本
          python clash_api_speedtest.py \
            --clash-url "http://127.0.0.1:9090" \
            --clash-secret "your_secret_token_here" \
            --input-file "filtered_nodes.yaml" \
            --output-file "clash_api_sorted.yaml" \
            --timeout 5000 \
            --concurrent 10 \
            --max-latency 3000 \
            --min-download 0.0 \ # 保持为0，因为目前不支持下载测速
            --min-upload 0.0 \   # 保持为0，因为目前不支持上传测速
            --sort latency \     # 目前只支持延迟排序
            --rename # 告诉脚本是否重命名节点

      - name: 验证生成的 clash_api_sorted.yaml 文件并计数节点
        id: count_nodes_api
        if: success() && steps.check_filtered_file.outputs.FILTERED_NODES_EMPTY == 'false' && steps.run_api_speedtest.outcome == 'success'
        run: |
          if [ -f "clash_api_sorted.yaml" ]; then
            echo "'clash_api_sorted.yaml' 文件已生成，大小: $(du -h clash_api_sorted.yaml | awk '{print $1}')"
            echo "--- clash_api_sorted.yaml 文件内容 (前50行) ---"
            head -n 50 clash_api_sorted.yaml || true
            echo "----------------------------------------"
            NODE_COUNT=$(grep -c 'name:' clash_api_sorted.yaml) # 仍然通过 'name:' 计数
            echo "检测到 ${NODE_COUNT} 个代理节点。"
            echo "NODE_COUNT=${NODE_COUNT}" >> $GITHUB_OUTPUT
            if [ "${NODE_COUNT}" -eq 0 ]; then
              echo "警告: 'clash_api_sorted.yaml' 文件中没有检测到代理节点。可能所有节点都未通过速度测试后的过滤。"
            fi
          else
            echo "错误: 未生成 'clash_api_sorted.yaml'。API 速度测试可能失败或没有通过过滤的节点。"
            echo "NODE_COUNT=0"
