# Workflow Name
name: Clash API Speed Test and Sort

# Triggers for the workflow
on:
  workflow_dispatch: # Allows manual triggering from the GitHub Actions UI
  schedule:
    - cron: '0 */4 * * *' # Runs every 4 hours (e.g., 00:00, 04:00, 08:00, etc. UTC). Adjust if needed.

jobs:
  api-speed-test:
    runs-on: ubuntu-latest # Specifies the runner environment (Ubuntu Linux)

    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4 # Checks out your repository code

      - name: Set Up Python Environment
        uses: actions/setup-python@v5
        with:
          python-version: '3.x' # Uses the latest Python 3 version available

      - name: Install Python Dependencies
        run: |
          pip install PyYAML requests aiohttp # Installs necessary Python libraries, including aiohttp

      - name: Download Clash Core (Mihomo)
        id: download_clash_core # Assigns an ID for referencing outputs
        run: |
          # We recommend Mihomo as the Clash Core.
          # Always check https://github.com/MetaCubeX/mihomo/releases for the latest stable version.
          MIHOMO_VERSION="1.19.11" # Update this to the latest stable version if needed
          ARCHIVE_NAME="mihomo-linux-amd64-v${MIHOMO_VERSION}.gz" # The correct file for Linux AMD64
          MIHOMO_URL="https://github.com/MetaCubeX/mihomo/releases/download/v${MIHOMO_VERSION}/${ARCHIVE_NAME}"
          EXECUTABLE_SOURCE_NAME="mihomo-linux-amd64-v${MIHOMO_VERSION}" # Name after gzip decompression
          EXECUTABLE_NAME="mihomo" # Desired final executable name

          echo "Attempting to download Mihomo Core ${ARCHIVE_NAME} from ${MIHOMO_URL}..."
          # Use curl with retries and timeouts for robust downloading
          curl -S -L --retry 5 --retry-delay 5 --connect-timeout 10 --max-time 60 --output "$ARCHIVE_NAME" "$MIHOMO_URL"
          if [ $? -ne 0 ]; then
            echo "Error: curl command failed, unable to download Mihomo Core."
            exit 1
          fi
          if [ ! -f "$ARCHIVE_NAME" ]; then
            echo "Error: Mihomo Core file does not exist. Download may have failed."
            exit 1
          fi
          if [ ! -s "$ARCHIVE_NAME" ]; then
            echo "Error: Mihomo Core file is empty. Download may have failed."
            exit 1
          fi
          echo "Mihomo Core downloaded successfully, size: $(du -h "$ARCHIVE_NAME" | awk '{print $1}')"

          echo "Decompressing ${ARCHIVE_NAME}..."
          gzip -d "$ARCHIVE_NAME" # Decompresses the .gz file

          # Rename the decompressed file to the desired executable name
          if [ -f "./${EXECUTABLE_SOURCE_NAME}" ]; then
            echo "Renaming '${EXECUTABLE_SOURCE_NAME}' to '${EXECUTABLE_NAME}'..."
            mv "./${EXECUTABLE_SOURCE_NAME}" "./${EXECUTABLE_NAME}"
          else
            echo "Error: Original executable file '${EXECUTABLE_SOURCE_NAME}' not found after decompression."
            exit 1
          fi

          # Verify the file type and make it executable
          FILE_TYPE_INFO=$(file "./${EXECUTABLE_NAME}")
          echo "${EXECUTABLE_NAME} file type information: ${FILE_TYPE_INFO}"
          if ! echo "$FILE_TYPE_INFO" | grep -q "ELF 64-bit LSB executable"; then
              echo "Error: ${EXECUTABLE_NAME} is not the expected Linux AMD64 executable. Check for corruption or wrong version."
              exit 1
          fi
          chmod +x "./${EXECUTABLE_NAME}" # Makes the file executable
          echo "'${EXECUTABLE_NAME}' permissions set and verified as executable."

      - name: Download Full Clash Configuration
        id: download_config # Assigns an ID for referencing outputs
        run: |
          # Replace this URL with the actual URL of your raw Clash configuration file.
          # Ensure this URL points to a file that contains a 'proxies' section or 'proxy-providers'.
          CONFIG_URL="https://raw.githubusercontent.com/qjlxg/vt/refs/heads/main/clash_config.yaml"
          OUTPUT_FILE="clash_config.yaml"
          echo "Attempting to download full Clash configuration from $CONFIG_URL..."
          curl -S -L -v --retry 5 --retry-delay 5 --connect-timeout 10 --max-time 60 --output "$OUTPUT_FILE" "$CONFIG_URL"
          if [ $? -ne 0 ]; then
            echo "Error: curl command failed, unable to download config file."
            exit 1
          fi
          if [ ! -f "$OUTPUT_FILE" ]; then
            echo "Error: $OUTPUT_FILE file does not exist after download."
            exit 1
          fi
          if [ ! -s "$OUTPUT_FILE" ]; then
            echo "Error: $OUTPUT_FILE file is empty. Check the download source."
            head -n 20 "$OUTPUT_FILE" || true # Shows first 20 lines if not empty, for debugging
            exit 1
          fi
          echo "$OUTPUT_FILE downloaded successfully, size: $(du -h "$OUTPUT_FILE" | awk '{print $1}')"

      - name: Filter Nodes (Using Python Script)
        run: python filter_clash_nodes.py # Executes your node filtering script

      - name: Validate Filtered File
        id: check_filtered_file # Assigns an ID for referencing outputs
        run: |
          if [ ! -s "filtered_nodes.yaml" ]; then
            echo "Warning: 'filtered_nodes.yaml' is empty or contains no valid content. No nodes might have matched filter conditions."
            echo "FILTERED_NODES_EMPTY=true" >> $GITHUB_OUTPUT # Sets an output for conditional steps
            head -n 20 filtered_nodes.yaml || true
            exit 0 # Exit successfully if no nodes, but mark as empty
          fi
          echo "filtered_nodes.yaml file size: $(du -h filtered_nodes.yaml | awk '{print $1}')"
          echo "FILTERED_NODES_EMPTY=false" >> $GITHUB_OUTPUT # Sets an output for conditional steps

      - name: Prepare Clash Core Configuration for Mihomo
        # This step runs only if filtered_nodes.yaml is not empty
        if: steps.check_filtered_file.outputs.FILTERED_NODES_EMPTY == 'false'
        run: |
          echo "Generating Mihomo startup configuration..."
          # Mihomo will automatically load provider files if specified via path in proxy-providers.
          # We use a placeholder secret, remember to replace it with your actual secure secret.
          cat > mihomo_config.yaml <<EOF
          port: 7890
          socks-port: 7891
          allow-lan: false
          mode: rule
          log-level: info
          external-controller: 127.0.0.1:9090
          secret: your_secret_token_here # *** IMPORTANT: REPLACE WITH YOUR ACTUAL SECURE KEY ***

          proxy-providers:
            filtered-proxies:
              type: file
              path: filtered_nodes.yaml # References the filtered nodes file
              interval: 3600 # Update interval (not critical here as we're doing one-shot speedtest)
              health-check:
                enable: false # Disable health checks to prevent interference during speedtest
          
          # We've removed the 'proxies' and 'rules' sections that previously used Go template syntax.
          # Mihomo will load proxies from 'filtered_nodes.yaml' via the 'proxy-providers' section.
          # The Python speed test script will then query Mihomo for the loaded proxies via its API.
          EOF
          
          echo "mihomo_config.yaml generated:"
          cat mihomo_config.yaml

      - name: Start Clash Core (Mihomo)
        id: start_clash_core # Assigns an ID for referencing outputs
        # This step runs only if previous steps were successful and filtered_nodes.yaml is not empty
        if: success() && steps.check_filtered_file.outputs.FILTERED_NODES_EMPTY == 'false'
        run: |
          echo "Starting Mihomo Core in background..."
          # -d specifies the working directory
          # -f specifies the configuration file
          ./mihomo -d . -f mihomo_config.yaml & # Starts Mihomo in the background
          MIHOMO_PID=$! # Captures the process ID of Mihomo
          echo "Mihomo Core started, PID: $MIHOMO_PID"
          # Give Mihomo some time to start up and listen on ports
          sleep 5

          # Verify Mihomo is listening on the external controller port
          if ! netstat -tuln | grep -q "127.0.0.1:9090"; then
            echo "Error: Mihomo Core did not start on port 9090. Check logs for details."
            kill $MIHOMO_PID || true # Attempt to kill the process if it failed to start
            exit 1
          fi
          echo "Mihomo Core successfully started and listening on 9090."
          echo "MIHOMO_PID=$MIHOMO_PID" >> $GITHUB_OUTPUT # Exports PID for the cleanup step

      - name: Run Python Script for API Speed Test and Sort
        id: run_api_speedtest # Assigns an ID for referencing outputs
        # This step runs only if previous steps were successful and Mihomo started
        if: success() && steps.check_filtered_file.outputs.FILTERED_NODES_EMPTY == 'false' && steps.start_clash_core.outcome == 'success'
        run: |
          echo "Starting Python script for API speed test and sorting..."
          # Pass Clash API parameters to the Python script
          # Removed inline comments to prevent Bash argument parsing errors.
          python clash_api_speedtest.py \
            --clash-url "http://127.0.0.1:9090" \
            --clash-secret "your_secret_token_here" \
            --input-file "filtered_nodes.yaml" \
            --output-file "clash_api_sorted.yaml" \
            --timeout 5000 \
            --concurrent 10 \
            --max-latency 3000 \
            --min-download 0.0 \
            --min-upload 0.0 \
            --sort latency \
            --rename

      - name: Validate Generated clash_api_sorted.yaml and Count Nodes
        id: count_nodes_api
        # This step runs only if previous steps were successful and the speed test script ran
        if: success() && steps.check_filtered_file.outputs.FILTERED_NODES_EMPTY == 'false' && steps.run_api_speedtest.outcome == 'success'
        run: |
          if [ -f "clash_api_sorted.yaml" ]; then
            echo "'clash_api_sorted.yaml' generated, size: $(du -h clash_api_sorted.yaml | awk '{print $1}')"
            echo "--- clash_api_sorted.yaml content (first 50 lines) ---"
            head -n 50 clash_api_sorted.yaml || true # Shows the first 50 lines of the generated file
            echo "----------------------------------------"
            # Count nodes by counting lines containing 'name:' (a common pattern for nodes)
            NODE_COUNT=$(grep -c 'name:' clash_api_sorted.yaml)
            echo "Detected ${NODE_COUNT} proxy nodes."
            echo "NODE_COUNT=${NODE_COUNT}" >> $GITHUB_OUTPUT # Exports node count for conditional steps
            if [ "${NODE_COUNT}" -eq 0 ]; then
              echo "Warning: No proxy nodes detected in 'clash_api_sorted.yaml'. All nodes might have failed speed tests or filtering."
            fi
          else
            echo "Error: 'clash_api_sorted.yaml' was not generated. API speed test may have failed or found no valid nodes."
            echo "NODE_COUNT=0" >> $GITHUB_OUTPUT
            exit 1
          fi
      
      - name: Backup Old Clash Config (API)
        # This step runs only if previous steps were successful and nodes were found
        if: success() && steps.check_filtered_file.outputs.FILTERED_NODES_EMPTY == 'false' && steps.count_nodes_api.outputs.NODE_COUNT > 0
        run: |
          if [ ! -f "clash_api_sorted.yaml" ]; then
            echo "Warning: 'clash_api_sorted.yaml' does not exist, skipping old config backup."
            exit 0
          fi
          mkdir -p sc_api # Creates a directory for backups
          TIMESTAMP=$(date +%Y%m%d_%H%M%S) # Generates a timestamp for the backup file
          echo "Backing up old clash_api_sorted.yaml to sc_api/clash_api_${TIMESTAMP}.yaml..."
          cp clash_api_sorted.yaml sc_api/clash_api_${TIMESTAMP}.yaml # Copies the file
          echo "Old config backup complete."

      - name: Commit and Push Sorted Clash Config (API)
        # This step commits and pushes only if previous steps were successful and nodes were found
        if: success() && steps.check_filtered_file.outputs.FILTERED_NODES_EMPTY == 'false' && steps.count_nodes_api.outputs.NODE_COUNT > 0
        uses: stefanzweifel/git-auto-commit-action@v5 # Action to automatically commit changes
        with:
          commit_message: "Update Clash Config (API Speed Test): Nodes sorted by latency and old config backed up"
          file_pattern: "clash_api_sorted.yaml sc_api/" # Specifies which files to commit (new config and backup dir)
          branch: main # The branch to commit to
          commit_user_name: github-actions[bot] # Commit user name
          commit_user_email: 41898282+github-actions[bot]@users.noreply.github.com # Commit user email
          commit_author: qjlxg <12179157+qjlxg@users.noreply.github.com> # Custom author for clarity
          repository: . # The current repository
          skip_dirty_check: false
          skip_fetch: false
          skip_checkout: false
          disable_globbing: false
          create_branch: false
          create_git_tag_only: false
          internal_git_binary: git
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }} # Uses the default GITHUB_TOKEN for authentication
      
      - name: Stop Clash Core (Mihomo)
        # This step always runs (even if previous steps fail) to ensure Mihomo is stopped.
        # It only attempts to kill if Mihomo was successfully started and its PID was captured.
        if: always() && steps.start_clash_core.outcome == 'success' && steps.start_clash_core.outputs.MIHOMO_PID
        run: |
          echo "Stopping Mihomo Core (PID: ${{ steps.start_clash_core.outputs.MIHOMO_PID }})..."
          # Attempt graceful kill first
          kill ${{ steps.start_clash_core.outputs.MIHOMO_PID }} || true
          sleep 2 # Give it some time to shut down
          # If still running, force kill
          if ps -p ${{ steps.start_clash_core.outputs.MIHOMO_PID }} > /dev/null; then
            echo "Mihomo Core did not stop gracefully, attempting to force kill."
            kill -9 ${{ steps.start_clash_core.outputs.MIHOMO_PID }} || true
          else
            echo "Mihomo Core stopped successfully."
          fi
