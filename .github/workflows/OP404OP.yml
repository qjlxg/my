# 新的工作流名称，用于 OP404OP/clash-speedtest
name: OP404OP Clash 速度测试 (独立)

# 触发工作流的事件
on:
  # 允许手动触发工作流
  workflow_dispatch:
  # 定时触发工作流
  schedule:
    # cron 表达式，表示每天的 0点和 12点运行 (可以根据你的需求调整)
    - cron: '0 0,12 * * *'

# 定义一个名为 "op404op-speed-test" 的作业
jobs:
  op404op-speed-test:
    # 指定作业运行的操作系统环境
    runs-on: ubuntu-latest

    # 定义作业中要执行的步骤
    steps:
      # 步骤 1: 检出仓库代码
      - name: 检出仓库
        uses: actions/checkout@v4

      # 步骤 2: 设置 Python 环境
      # 你的 filter_clash_nodes.py 脚本需要 Python 环境
      - name: 设置 Python 环境
        uses: actions/setup-python@v5
        with:
          python-version: '3.x'

      # 步骤 3: 安装 Python 依赖
      # PyYAML 库用于处理 YAML 文件
      - name: 安装 Python 依赖
        run: |
          pip install PyYAML

      # 步骤 4: 下载完整的 Clash 配置
      # 这是你的主 Clash 配置文件，包含所有原始节点
      - name: 下载完整的 Clash 配置
        id: download_config # 为此步骤设置ID，以便后续引用其状态
        run: |
          # 定义 Clash 配置文件的下载 URL。请替换为你的实际地址。
          CONFIG_URL="https://raw.githubusercontent.com/qjlxg/vt/refs/heads/main/clash_config.yaml"
          OUTPUT_FILE="clash_config.yaml"

          echo "尝试从 $CONFIG_URL 下载完整的 Clash 配置文件..."
          curl -S -L -v --retry 5 --retry-delay 5 --connect-timeout 10 --max-time 60 --output "$OUTPUT_FILE" "$CONFIG_URL"

          if [ $? -ne 0 ]; then
            echo "错误: curl 命令执行失败，无法下载文件。"
            exit 1
          fi
          if [ ! -f "$OUTPUT_FILE" ]; then
            echo "错误: $OUTPUT_FILE 文件不存在。"
            exit 1
          fi
          if [ ! -s "$OUTPUT_FILE" ]; then
            echo "错误: $OUTPUT_FILE 文件为空。"
            head -n 20 "$OUTPUT_FILE" || true
            exit 1
          fi
          echo "$OUTPUT_FILE 文件下载成功，大小: $(du -h "$OUTPUT_FILE" | awk '{print $1}')"

      # 步骤 5: 过滤节点 (使用 Python 脚本)
      # 运行你的 filter_clash_nodes.py 脚本，生成 filtered_nodes.yaml
      - name: 过滤节点 (使用 Python 脚本)
        run: python filter_clash_nodes.py

      # 步骤 6: 验证过滤后的文件
      # 检查 filtered_nodes.yaml 是否有效，并设置输出变量以供后续步骤判断
      - name: 验证过滤后的文件
        id: check_filtered_file # 为此步骤设置ID
        run: |
          if [ ! -s "filtered_nodes.yaml" ]; then
            echo "警告: 'filtered_nodes.yaml' 文件为空或无有效内容。可能没有节点符合过滤条件。"
            # 使用 `echo "name=value" >> $GITHUB_OUTPUT` 来设置输出变量
            echo "FILTERED_NODES_EMPTY=true" >> $GITHUB_OUTPUT
            head -n 20 filtered_nodes.yaml || true
            exit 0 # 如果文件为空，不中断工作流，但设置警告
          fi
          echo "filtered_nodes.yaml 文件大小: $(du -h filtered_nodes.yaml | awk '{print $1}')"
          echo "FILTERED_NODES_EMPTY=false" >> $GITHUB_OUTPUT

      # 步骤 7: 下载 OP404OP/clash-speedtest 二进制文件
      # 从 OP404OP 的 GitHub Releases 下载其 speedtest 工具
      - name: 下载 OP404OP/clash-speedtest 工具
        id: download_op404op_tool # 给这个步骤一个ID，以便后续引用其结果
        run: |
          # 访问 https://github.com/OP404OP/clash-speedtest/releases 获取最新版本链接
          # ！！！重要：请定期检查并更新这里的 TOOL_VERSION 为最新版本！！！
          # 当前根据 GitHub Releases 页面，v1.6.3 是最新版，Linux AMD64 文件名为 clash-speedtest-linux-x86_64
          TOOL_VERSION="v1.6.3"
          TOOL_FILENAME="clash-speedtest-linux-x86_64" # 确认这个文件名是针对 Linux AMD64 的
          TOOL_URL="https://github.com/OP404OP/clash-speedtest/releases/download/${TOOL_VERSION}/${TOOL_FILENAME}"
          OUTPUT_PATH="./clash-speedtest-op404op" # 避免与你的原有工具名称冲突

          echo "尝试从 $TOOL_URL 下载 OP404OP/clash-speedtest 工具..."
          curl -S -L -v --retry 5 --retry-delay 5 --connect-timeout 10 --max-time 60 --output "$OUTPUT_PATH" "$TOOL_URL"

          if [ $? -ne 0 ]; then
            echo "错误: curl 命令执行失败，无法下载 OP404OP/clash-speedtest 工具。请检查 TOOL_URL 是否正确或网络问题。"
            exit 1
          fi
          if [ ! -f "$OUTPUT_PATH" ]; then
            echo "错误: $OUTPUT_PATH 文件不存在。下载可能未成功。"
            exit 1
          fi
          if [ ! -s "$OUTPUT_PATH" ]; then
            echo "错误: $OUTPUT_PATH 文件为空。下载的文件内容可能不正确。"
            head -n 20 "$OUTPUT_PATH" || true # 打印文件开头帮助诊断
            exit 1
          fi

          echo "OP404OP/clash-speedtest 工具下载成功，大小: $(du -h "$OUTPUT_PATH" | awk '{print $1}')"

          # ***关键检查：验证文件类型是否为可执行二进制文件***
          echo "检查下载文件的类型..."
          FILE_TYPE_INFO=$(file "$OUTPUT_PATH")
          echo "文件类型信息: $FILE_TYPE_INFO"

          # 确保文件是 ELF 64-bit LSB executable (Linux AMD64 的可执行文件标识)
          if ! echo "$FILE_TYPE_INFO" | grep -q "ELF 64-bit LSB executable"; then
              echo "错误: 下载的文件不是预期的 Linux AMD64 可执行文件。可能是下载了错误的文件或文件已损坏。"
              echo "请检查 TOOL_URL 和 TOOL_FILENAME 是否正确指向了 'clash-speedtest-linux-x86_64' 二进制文件。"
              exit 1
          fi

          chmod +x "$OUTPUT_PATH" # 赋予执行权限
          echo "赋予 OP404OP/clash-speedtest 执行权限完成。"
          # 设置一个输出变量，表示工具是否成功下载
          echo "OP_TOOL_DOWNLOADED=true" >> $GITHUB_OUTPUT

      # 步骤 8: 运行 OP404OP/clash-speedtest 进行高级测试
      # 对过滤后的节点运行 OP404OP 工具，启用解锁和风险检测
      - name: 运行 OP404OP/clash-speedtest 进行高级测试
        # 仅当 filtered_nodes.yaml 不为空且 OP404OP 工具下载成功时才执行
        if: success() && steps.check_filtered_file.outputs.FILTERED_NODES_EMPTY == 'false' && steps.download_op404op_tool.outputs.OP_TOOL_DOWNLOADED == 'true'
        run: |
          mkdir -p sc # 确保 sc 目录存在，用于存放结果
          echo "开始使用 OP404OP/clash-speedtest 运行高级速度和解锁测试..."
          ./clash-speedtest-op404op \
            -c ./filtered_nodes.yaml \ # 使用过滤后的节点作为输入
            -output sc/OP404OP.yaml \ # 将结果输出到 sc/OP404OP.yaml
            -download-size 5 \
            -upload-size 1 \
            -timeout 38s \
            -concurrent 50 \
            -max-latency 5000ms \
            -min-download-speed 1 \
            -min-upload-speed 0 \
            -unlock \ # 启用流媒体解锁检测
            -risk \ # 启用 IP 风险检测
            -rename # 根据 OP404OP 文档，此参数通常用于重命名节点，可保留
          echo "OP404OP/clash-speedtest 测试完成，结果保存到 sc/OP404OP.yaml"

      # 步骤 9: 验证 OP404OP/clash-speedtest 生成的文件
      # 检查生成的 sc/OP404OP.yaml 文件是否有效
      - name: 验证 OP404OP/clash-speedtest 生成的文件
        # 仅当 OP404OP 工具下载成功时才检查 (因为上一步可能因为节点问题仍旧失败)
        if: success() && steps.download_op404op_tool.outputs.OP_TOOL_DOWNLOADED == 'true'
        run: |
          if [ -f "sc/OP404OP.yaml" ]; then
            echo "'sc/OP404OP.yaml' 文件已生成，大小: $(du -h sc/OP404OP.yaml | awk '{print $1}')"
            echo "--- sc/OP404OP.yaml 文件内容 (前50行) ---"
            head -n 50 sc/OP404OP.yaml || true
            echo "----------------------------------------"
            # 检查文件中是否包含代理节点，如果没有则发出警告
            if [ "$(grep -c 'name:' sc/OP404OP.yaml)" -eq 0 ]; then
              echo "警告: 'sc/OP404OP.yaml' 文件中没有检测到代理节点。可能所有节点都未通过 OP404OP/clash-speedtest 的过滤。"
            fi
          else
            echo "警告: 未生成 'sc/OP404OP.yaml'。OP404OP/clash-speedtest 可能失败或没有通过过滤的节点。"
          fi

      # 步骤 10: 提交并推送 OP404OP 配置文件
      # 使用 git-auto-commit-action 将结果文件推送到仓库
      - name: 提交并推送 OP404OP 配置文件
        # 仅当前面的步骤成功，并且 OP404OP 工具成功下载时才尝试提交。
        # 文件存在及内容检查已在之前的 run 脚本中处理。
        if: success() && steps.download_op404op_tool.outputs.OP_TOOL_DOWNLOADED == 'true'
        uses: stefanzweifel/git-auto-commit-action@v5
        with:
          commit_message: "更新 OP404OP Clash 配置：节点已按速度排序并包含解锁信息"
          file_pattern: "sc/OP404OP.yaml" # 只提交这个文件
          branch: main
          commit_user_name: github-actions[bot]
          commit_user_email: 41898282+github-actions[bot]@users.noreply.github.com
          commit_author: qjlxg <12179157+qjlxg@users.noreply.github.com>
          repository: .
          skip_dirty_check: false
          skip_fetch: false
          skip_checkout: false
          disable_globbing: false
          create_branch: false
          create_git_tag_only: false
          internal_git_binary: git
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
