# 工作流名称
name: Clash Speed Test (xiecang)

# 触发工作流的事件
on:
  workflow_dispatch: # 手动触发
  schedule:
    - cron: '0 */4 * * *' # 每4小时运行一次，可以根据需要调整

jobs:
  speed-test-xiecang:
    runs-on: ubuntu-latest
    steps:
      - name: 检出仓库
        uses: actions/checkout@v4

      - name: 设置 Python 环境
        uses: actions/setup-python@v5
        with:
          python-version: '3.x'

      - name: 安装 Python 依赖
        run: |
          pip install PyYAML

      - name: 下载并赋予 xiecang/speedtest-clash 执行权限
        run: |
          TOOL_ARCHIVE_NAME="speedtest-clash_Linux_x86_64.tar.gz" # 完整的压缩包名称
          TOOL_NAME_EXPECTED="clash-speedtest" # 我们期望的可执行文件名称 (重命名后的目标名称)
          # 这是v0.2.4版本的完整下载链接。如果未来有新版本，您可能需要更新此链接。
          TOOL_URL="https://github.com/xiecang/speedtest-clash/releases/download/v0.2.4/$TOOL_ARCHIVE_NAME" 
          # 解压后可能创建的目录名 (从压缩包名推断，用于清理，非核心逻辑)
          EXTRACTED_ROOT_DIR="speedtest-clash_Linux_x86_64"

          echo "尝试下载 '$TOOL_ARCHIVE_NAME'..."
          curl -S -L --retry 5 --retry-delay 5 --connect-timeout 10 --max-time 60 --output "$TOOL_ARCHIVE_NAME" "$TOOL_URL"
          if [ $? -ne 0 ]; then
            echo "错误: curl 命令执行失败，无法下载 '$TOOL_ARCHIVE_NAME' 文件。"
            exit 1
          fi
          if [ ! -f "$TOOL_ARCHIVE_NAME" ]; then
            echo "错误: '$TOOL_ARCHIVE_NAME' 文件不存在。下载可能失败。"
            exit 1
          fi
          if [ ! -s "$TOOL_ARCHIVE_NAME" ]; then
            echo "错误: '$TOOL_ARCHIVE_NAME' 文件为空。下载可能失败。"
            exit 1
          fi
          echo "'$TOOL_ARCHIVE_NAME' 下载成功，大小: $(du -h "$TOOL_ARCHIVE_NAME" | awk '{print $1}')"

          echo "解压 '$TOOL_ARCHIVE_NAME'..."
          tar -xzf "$TOOL_ARCHIVE_NAME" # 解压 .tar.gz 文件
          
          echo "--- 调试信息：解压后文件列表 ---"
          ls -RF # 列出所有解压后的文件和目录结构，用于调试确认
          echo "---------------------------------"

          # **核心逻辑：自动查找并处理可执行文件**
          # 查找解压后任何被识别为 "ELF 64-bit LSB executable" 类型的文件
          # 使用 `find` 配合 `file` 命令来判断文件类型
          # `head -n 1` 确保只取第一个找到的可执行文件，因为通常只有一个
          FOUND_EXECUTABLE_PATH=$(find . -type f -print0 | xargs -0 file | grep "ELF 64-bit LSB executable" | head -n 1 | awk -F: '{print $1}')

          if [ -z "$FOUND_EXECUTABLE_PATH" ]; then
            echo "错误: 未在解压后的文件中找到任何 ELF 64-bit LSB 可执行文件。"
            echo "请检查 '$TOOL_ARCHIVE_NAME' 压缩包的内容是否符合预期。"
            exit 1
          fi

          echo "成功找到可执行文件，原始路径: '$FOUND_EXECUTABLE_PATH'"

          # 如果找到的可执行文件不在根目录或者名称不是期望的，则移动并重命名
          if [ "$FOUND_EXECUTABLE_PATH" != "./$TOOL_NAME_EXPECTED" ]; then
            echo "正在将可执行文件移动并重命名到根目录为 '$TOOL_NAME_EXPECTED'..."
            mv "$FOUND_EXECUTABLE_PATH" "./$TOOL_NAME_EXPECTED"
            if [ $? -ne 0 ]; then
              echo "错误: 移动或重命名文件失败。"
              exit 1
            fi
            echo "文件移动和重命名成功。"
          else
            echo "可执行文件 '$FOUND_EXECUTABLE_PATH' 已在根目录并符合预期名称。"
          fi
          
          # 最终确认可执行文件存在且可用
          if [ ! -f "./$TOOL_NAME_EXPECTED" ]; then
            echo "错误: 最终的可执行文件 './$TOOL_NAME_EXPECTED' 不存在。"
            exit 1
          fi

          # 赋予执行权限并再次验证文件类型
          FILE_TYPE_INFO=$(file "./$TOOL_NAME_EXPECTED")
          echo "'$TOOL_NAME_EXPECTED' 文件类型信息: $FILE_TYPE_INFO"
          if ! echo "$FILE_TYPE_INFO" | grep -q "ELF 64-bit LSB executable"; then
              echo "错误: '$TOOL_NAME_EXPECTED' 文件不是预期的 Linux AMD64 可执行文件。请检查文件是否损坏或上传了错误版本。"
              exit 1
          fi
          chmod +x "./$TOOL_NAME_EXPECTED"
          echo "'$TOOL_NAME_EXPECTED' 权限已设置并验证为可执行文件。"

      - name: 下载完整的 Clash 配置
        id: download_config
        run: |
          CONFIG_URL="https://raw.githubusercontent.com/qjlxg/vt/refs/heads/main/clash_config.yaml"
          OUTPUT_FILE="clash_config.yaml"
          echo "尝试从 $CONFIG_URL 下载完整的 Clash 配置文件..."
          curl -S -L -v --retry 5 --retry-delay 5 --connect-timeout 10 --max-time 60 --output "$OUTPUT_FILE" "$CONFIG_URL"
          if [ $? -ne 0 ]; then
            echo "错误: curl 命令执行失败，无法下载文件。"
            exit 1
          fi
          if [ ! -f "$OUTPUT_FILE" ]; then
            echo "错误: $OUTPUT_FILE 文件不存在。"
            exit 1
          fi
          if [ ! -s "$OUTPUT_FILE" ]; then
            echo "错误: $OUTPUT_FILE 文件为空。"
            head -n 20 "$OUTPUT_FILE" || true
            exit 1
          fi
          echo "$OUTPUT_FILE 文件下载成功，大小: $(du -h "$OUTPUT_FILE" | awk '{print $1}')"

      - name: 过滤节点 (使用 Python 脚本)
        run: python filter_clash_nodes.py
      
      - name: 验证过滤后的文件
        id: check_filtered_file
        run: |
          if [ ! -s "filtered_nodes.yaml" ]; then
            echo "警告: 'filtered_nodes.yaml' 文件为空或无有效内容。可能没有节点符合过滤条件。"
            echo "FILTERED_NODES_EMPTY=true" >> $GITHUB_OUTPUT 
            head -n 20 filtered_nodes.yaml || true
            exit 0
          fi
          echo "filtered_nodes.yaml 文件大小: $(du -h filtered_nodes.yaml | awk '{print $1}')"
          echo "FILTERED_NODES_EMPTY=false" >> $GITHUB_OUTPUT

      - name: 备份旧的 xiecang.yaml 配置
        if: steps.check_filtered_file.outputs.FILTERED_NODES_EMPTY == 'false'
        run: |
          if [ ! -f "xiecang.yaml" ]; then
            echo "警告: 'xiecang.yaml' 文件不存在，跳过备份旧配置。"
            exit 0
          fi
          mkdir -p sc_xiecang # 为 xiecang 脚本单独创建备份目录
          TIMESTAMP=$(date +%Y%m%d_%H%M%S)
          echo "正在备份旧的 xiecang.yaml 到 sc_xiecang/xiecang_${TIMESTAMP}.yaml..."
          cp xiecang.yaml sc_xiecang/xiecang_${TIMESTAMP}.yaml
          echo "旧配置备份完成。"

      - name: 运行 xiecang/speedtest-clash 速度测试
        id: run_speedtest_xiecang
        if: success() && steps.check_filtered_file.outputs.FILTERED_NODES_EMPTY == 'false'
        run: |
          echo "开始运行所有节点的完整速度测试 (使用 xiecang/speedtest-clash)..."
          # !!! 请注意，这里的参数是 xiecang/speedtest-clash 专用的 !!!
          ./clash-speedtest \
            -c ./filtered_nodes.yaml \
            -output ./xiecang.yaml \
            -size 20971520 \   # 测试下载 20MB 数据 (20 * 1024 * 1024 字节)
            -timeout 90s \     # 超时设置为 90 秒
            -concurrent 15 \   # 15 个并发测试
            -sort b            # 按带宽（下载速度）排序
           
          echo "xiecang/speedtest-clash 全速测试完成，结果保存到 xiecang.yaml"

      - name: 验证生成的 xiecang.yaml 文件并计数节点
        id: count_nodes_xiecang
        if: success() && steps.check_filtered_file.outputs.FILTERED_NODES_EMPTY == 'false' && steps.run_speedtest_xiecang.outcome == 'success'
        run: |
          if [ -f "xiecang.yaml" ]; then
            echo "'xiecang.yaml' 文件已生成，大小: $(du -h xiecang.yaml | awk '{print $1}')"
            echo "--- xiecang.yaml 文件内容 (前50行) ---"
            head -n 50 xiecang.yaml || true
            echo "----------------------------------------"
            NODE_COUNT=$(grep -c 'name:' xiecang.yaml) # 仍然通过 'name:' 计数
            echo "检测到 ${NODE_COUNT} 个代理节点。"
            echo "NODE_COUNT=${NODE_COUNT}" >> $GITHUB_OUTPUT
            if [ "${NODE_COUNT}" -eq 0 ]; then
              echo "警告: 'xiecang.yaml' 文件中没有检测到代理节点。可能所有节点都未通过速度测试后的过滤。"
            fi
          else
            echo "错误: 未生成 'xiecang.yaml'。速度测试可能失败或没有通过过滤的节点。"
            echo "NODE_COUNT=0" >> $GITHUB_OUTPUT
            exit 1
          fi

      - name: 提交并推送排序后的 xiecang 配置
        if: success() && steps.check_filtered_file.outputs.FILTERED_NODES_EMPTY == 'false' && steps.count_nodes_xiecang.outputs.NODE_COUNT > 0
        uses: stefanzweifel/git-auto-commit-action@v5
        with:
          commit_message: "更新 Clash 配置 (xiecang)：节点已按速度排序并备份旧配置"
          file_pattern: "xiecang.yaml sc_xiecang/" # 同时提交新的配置文件和其备份
          branch: main
          commit_user_name: github-actions[bot]
          commit_user_email: 41898282+github-actions[bot]@users.noreply.github.com
          commit_author: qjlxg <12179157+qjlxg@users.noreply.github.com>
          repository: .
          skip_dirty_check: false
          skip_fetch: false
          skip_checkout: false
          disable_globbing: false
          create_branch: false
          create_git_tag_only: false
          internal_git_binary: git
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
