# 工作流名称
name: Clash Speed Test (Ultimate)

# 触发工作流的事件
on:
  workflow_dispatch: # 手动触发
  schedule:
    - cron: '0 */4 * * *' # 每4小时运行一次，可以根据需要调整

jobs:
  speed-test-ultimate:
    runs-on: ubuntu-latest
    steps:
      - name: 检出仓库
        uses: actions/checkout@v4

      - name: 设置 Python 环境
        uses: actions/setup-python@v5
        with:
          python-version: '3.x'

      - name: 安装 Python 依赖
        run: |
          pip install PyYAML

      - name: 下载并配置 starudream/clash-speedtest 工具
        run: |
          # 根据最新发布信息更新
          TOOL_VERSION="3.0.1" 
          ARCHIVE_NAME="clash-speedtest_v${TOOL_VERSION}_linux_amd64.tar.gz"
          TOOL_URL="https://github.com/starudream/clash-speedtest/releases/download/v${TOOL_VERSION}/${ARCHIVE_NAME}"
          EXECUTABLE_NAME="clash-speedtest" # 解压后的可执行文件名称

          echo "尝试下载 ${ARCHIVE_NAME}..."
          curl -S -L --retry 5 --retry-delay 5 --connect-timeout 10 --max-time 60 --output "$ARCHIVE_NAME" "$TOOL_URL"
          if [ $? -ne 0 ]; then
            echo "错误: curl 命令执行失败，无法下载 ${ARCHIVE_NAME} 文件。"
            exit 1
          fi
          if [ ! -f "$ARCHIVE_NAME" ]; then
            echo "错误: ${ARCHIVE_NAME} 文件不存在。下载可能失败。"
            exit 1
          fi
          if [ ! -s "$ARCHIVE_NAME" ]; then
            echo "错误: ${ARCHIVE_NAME} 文件为空。下载可能失败。"
            exit 1
          fi
          echo "${ARCHIVE_NAME} 下载成功，大小: $(du -h "$ARCHIVE_NAME" | awk '{print $1}')"

          echo "解压 ${ARCHIVE_NAME}..."
          tar -xzf "$ARCHIVE_NAME"
          
          # 解压后通常会有一个名为 EXECUTABLE_NAME 的文件在当前目录或子目录
          if [ ! -f "./${EXECUTABLE_NAME}" ]; then
            # 尝试在解压的目录中查找并移动
            FOUND_PATH=$(find . -type f -name "${EXECUTABLE_NAME}" -print -quit)
            if [ -n "$FOUND_PATH" ]; then
              echo "找到 '${EXECUTABLE_NAME}' 在 '${FOUND_PATH}'，移动到当前目录..."
              mv "$FOUND_PATH" "./${EXECUTABLE_NAME}"
            else
              echo "错误: 未在解压后的文件中找到 '${EXECUTABLE_NAME}'。请检查压缩包内容。"
              exit 1
            fi
          fi

          FILE_TYPE_INFO=$(file "./${EXECUTABLE_NAME}")
          echo "${EXECUTABLE_NAME} 文件类型信息: ${FILE_TYPE_INFO}"
          if ! echo "$FILE_TYPE_INFO" | grep -q "ELF 64-bit LSB executable"; then
              echo "错误: ${EXECUTABLE_NAME} 文件不是预期的 Linux AMD64 可执行文件。请检查文件是否损坏或上传了错误版本。"
              exit 1
          fi
          chmod +x "./${EXECUTABLE_NAME}"
          echo "'${EXECUTABLE_NAME}' 权限已设置并验证为可执行文件。"

      - name: 下载完整的 Clash 配置
        id: download_config
        run: |
          CONFIG_URL="https://raw.githubusercontent.com/qjlxg/vt/refs/heads/main/clash_config.yaml"
          OUTPUT_FILE="clash_config.yaml"
          echo "尝试从 $CONFIG_URL 下载完整的 Clash 配置文件..."
          curl -S -L -v --retry 5 --retry-delay 5 --connect-timeout 10 --max-time 60 --output "$OUTPUT_FILE" "$CONFIG_URL"
          if [ $? -ne 0 ]; then
            echo "错误: curl 命令执行失败，无法下载文件。"
            exit 1
          fi
          if [ ! -f "$OUTPUT_FILE" ]; then
            echo "错误: $OUTPUT_FILE 文件不存在。"
            exit 1
          fi
          if [ ! -s "$OUTPUT_FILE" ]; then
            echo "错误: $OUTPUT_FILE 文件为空。"
            head -n 20 "$OUTPUT_FILE" || true
            exit 1
          fi
          echo "$OUTPUT_FILE 文件下载成功，大小: $(du -h "$OUTPUT_FILE" | awk '{print $1}')"

      - name: 过滤节点 (使用 Python 脚本)
        run: python filter_clash_nodes.py
      
      - name: 验证过滤后的文件
        id: check_filtered_file
        run: |
          if [ ! -s "filtered_nodes.yaml" ]; then
            echo "警告: 'filtered_nodes.yaml' 文件为空或无有效内容。可能没有节点符合过滤条件。"
            echo "FILTERED_NODES_EMPTY=true" >> $GITHUB_OUTPUT 
            head -n 20 filtered_nodes.yaml || true
            exit 0
          fi
          echo "filtered_nodes.yaml 文件大小: $(du -h filtered_nodes.yaml | awk '{print $1}')"
          echo "FILTERED_NODES_EMPTY=false" >> $GITHUB_OUTPUT

      - name: 备份旧的 Clash 配置 (Ultimate)
        if: success() && steps.check_filtered_file.outputs.FILTERED_NODES_EMPTY == 'false'
        run: |
          # 输出文件名为 clash_ultimate_sorted.yaml
          if [ ! -f "clash_ultimate_sorted.yaml" ]; then
            echo "警告: 'clash_ultimate_sorted.yaml' 文件不存在，跳过备份旧配置。"
            exit 0
          fi
          mkdir -p sc_ultimate # 为此脚本单独创建备份目录
          TIMESTAMP=$(date +%Y%m%d_%H%M%S)
          echo "正在备份旧的 clash_ultimate_sorted.yaml 到 sc_ultimate/clash_ultimate_${TIMESTAMP}.yaml..."
          cp clash_ultimate_sorted.yaml sc_ultimate/clash_ultimate_${TIMESTAMP}.yaml
          echo "旧配置备份完成。"

      - name: 运行 starudream/clash-speedtest 速度测试
        id: run_speedtest_ultimate
        if: success() && steps.check_filtered_file.outputs.FILTERED_NODES_EMPTY == 'false'
        run: |
          echo "开始运行所有节点的延迟和速度测试 (使用 starudream/clash-speedtest)..."
          # starudream/clash-speedtest 的参数
          # 检查此版本是否有 --rename 参数，如果报错可以移除。根据文档，它通常在输出中包含速度信息
          ./clash-speedtest \
            -c ./filtered_nodes.yaml \
            -o ./clash_ultimate_sorted.yaml \
            --timeout 5000 \        # 延迟测试超时 (毫秒)
            --concurrency 10 \      # 并发测试数量
            --dl-test-url "http://speedtest.tele2.net/100MB.zip" \ # 下载测试 URL
            --ul-test-url "https://speed.cloudflare.com/__up?bytes=10000000" \ # 上传测试 URL
            --download-size 20 \    # 下载测试大小 (MB)
            --upload-size 5 \       # 上传测试大小 (MB)
            --ping-count 3 \        # 每个节点 ping 次数
            --max-latency 3000 \    # 过滤延迟高于 3000ms 的节点
            --min-download 0.5 \    # 过滤下载速度低于 0.5 MB/s 的节点
            --min-upload 0.1 \      # 过滤上传速度低于 0.1 MB/s 的节点
            --sort download         # 按照下载速度排序 (latency, download, upload)
            # 根据其文档，v3.x版本默认会在节点名称后添加速度信息，不需要额外 --rename 参数
           
          echo "starudream/clash-speedtest 延迟和速度测试完成，结果保存到 clash_ultimate_sorted.yaml"

      - name: 验证生成的 clash_ultimate_sorted.yaml 文件并计数节点
        id: count_nodes_ultimate
        if: success() && steps.check_filtered_file.outputs.FILTERED_NODES_EMPTY == 'false' && steps.run_speedtest_ultimate.outcome == 'success'
        run: |
          if [ -f "clash_ultimate_sorted.yaml" ]; then
            echo "'clash_ultimate_sorted.yaml' 文件已生成，大小: $(du -h clash_ultimate_sorted.yaml | awk '{print $1}')"
            echo "--- clash_ultimate_sorted.yaml 文件内容 (前50行) ---"
            head -n 50 clash_ultimate_sorted.yaml || true
            echo "----------------------------------------"
            NODE_COUNT=$(grep -c 'name:' clash_ultimate_sorted.yaml) # 仍然通过 'name:' 计数
            echo "检测到 ${NODE_COUNT} 个代理节点。"
            echo "NODE_COUNT=${NODE_COUNT}" >> $GITHUB_OUTPUT
            if [ "${NODE_COUNT}" -eq 0 ]; then
              echo "警告: 'clash_ultimate_sorted.yaml' 文件中没有检测到代理节点。可能所有节点都未通过速度测试后的过滤。"
            fi
          else
            echo "错误: 未生成 'clash_ultimate_sorted.yaml'。速度测试可能失败或没有通过过滤的节点。"
            echo "NODE_COUNT=0" >> $GITHUB_OUTPUT
            exit 1
          fi

      - name: 提交并推送排序后的 Clash 配置 (Ultimate)
        if: success() && steps.check_filtered_file.outputs.FILTERED_NODES_EMPTY == 'false' && steps.count_nodes_ultimate.outputs.NODE_COUNT > 0
        uses: stefanzweifel/git-auto-commit-action@v5
        with:
          commit_message: "更新 Clash 配置 (Ultimate Speed Test)：节点已按速度排序并备份旧配置"
          file_pattern: "clash_ultimate_sorted.yaml sc_ultimate/" # 同时提交新的配置文件和其备份
          branch: main
          commit_user_name: github-actions[bot]
          commit_user_email: 41898282+github-actions[bot]@users.noreply.github.com
          commit_author: qjlxg <12179157+qjlxg@users.noreply.github.com>
          repository: .
          skip_dirty_check: false
          skip_fetch: false
          skip_checkout: false
          disable_globbing: false
          create_branch: false
          create_git_tag_only: false
          internal_git_binary: git
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
